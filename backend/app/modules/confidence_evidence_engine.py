from typing import List, Dict, Any, Set
import re

class ConfidenceEngine:
    """
    Assigns confidence levels and attributes evidence sources to intelligence findings using deterministic logic.
    """
    
    # Source Definitions and Reliability Weights
    # HIGH: Cryptographic proof, active confirmed connection, or verified leak.
    # MEDIUM: DNS records (can be stale), Headers (can be spoofed), specific server versions.
    # LOW: Heuristics, implied configuration, soft patterns.
    SOURCE_CONFIG = {
        "PORT": {"keyword": ["port", "service", "socket"], "reliability": "HIGH", "type": "Active Scan"},
        "LEAK": {"keyword": ["leak", "github", "API key", "credential"], "reliability": "HIGH", "type": "Verified Leak"},
        "SSL": {"keyword": ["ssl", "certificate", "tls"], "reliability": "HIGH", "type": "Cryptographic Evidence"},
        "DNS": {"keyword": ["dns", "spf", "dmarc", "record", "mx", "txt"], "reliability": "MEDIUM", "type": "DNS Record"},
        "HEADER": {"keyword": ["header", "x-powered-by", "server", "banner"], "reliability": "MEDIUM", "type": "HTTP Header"},
        "FILE": {"keyword": ["file", "directory", "index", "path"], "reliability": "MEDIUM", "type": "Public Content"},
        "TECH": {"keyword": ["tech", "framework", "software"], "reliability": "LOW", "type": "Fingerprint"},
        "GENERIC": {"keyword": [], "reliability": "LOW", "type": "Heuristic"}
    }

    @staticmethod
    def enrich_finding(finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Enriches a raw finding with 'confidence' score and 'evidence' attribution list.
        """
        signals = finding.get("signals", [])
        if not signals:
             # Fallback if no signals present
             finding["confidence"] = "Low"
             finding["evidence"] = []
             return finding

        # 1. Attribute Evidence Sources
        evidence_list = []
        source_types = set()
        total_reliability_score = 0
        
        for signal in signals:
            signal_str = str(signal).lower()
            attributed_source = "GENERIC"
            
            # Simple keyword matching for attribution
            for source, config in ConfidenceEngine.SOURCE_CONFIG.items():
                if any(k in signal_str for k in config["keyword"]):
                    attributed_source = source
                    break # Take the first match (prioritize order in CONFIG if needed, but dicts are unordered usually. 
                          # Ideally we'd sort config, but this is simple.)
            
            source_info = ConfidenceEngine.SOURCE_CONFIG.get(attributed_source, ConfidenceEngine.SOURCE_CONFIG["GENERIC"])
            
            evidence_item = {
                "signal": str(signal),
                "source_type": source_info["type"],
                "reliability": source_info["reliability"]
            }
            evidence_list.append(evidence_item)
            source_types.add(source_info["type"])
            
            # Scoring
            if source_info["reliability"] == "HIGH":
                total_reliability_score += 3
            elif source_info["reliability"] == "MEDIUM":
                total_reliability_score += 2
            else:
                total_reliability_score += 1

        # 2. Calculate Confidence Level
        # Criteria:
        # HIGH: At least one HIGH reliability source OR >2 independent source types with good score.
        # MEDIUM: At least one MEDIUM source OR multiple LOW.
        # LOW: Single LOW source or weak signal.
        
        has_high_source = any(e["reliability"] == "HIGH" for e in evidence_list)
        num_sources = len(source_types)
        
        confidence = "Low"
        
        if has_high_source:
            confidence = "High"
        elif num_sources >= 2 and total_reliability_score >= 4:
            # e.g. 2 Mediums (2+2=4) -> High Confidence? Or maybe just "High-Medium"?
            # Let's be conservative. If we have 2 distinct Medium sources (e.g. DNS + Header confirming something) -> Medium-High -> High.
            confidence = "High"
        elif total_reliability_score >= 3:
            # e.g. 1 High (handled above), or 1 Med + 1 Low, or 3 Lows.
            confidence = "Medium"
        else:
            confidence = "Low"

        # Special Case: Critical Severity often implies High Confidence if generated by our rules, 
        # but let's trust the evidence. If Severity is Critical but we only have a "Low" confidence evidence, 
        # we should probably flag it. But for now, we just output the calculated confidence.

        finding["confidence"] = confidence
        finding["evidence"] = evidence_list
        
        return finding

    @staticmethod
    def calculate_module_confidence(module_name: str, data: Dict[str, Any]) -> Dict[str, str]:
        """
        Calculates confidence scores for specific module output fields.
        Returns a dictionary mapping field names to confidence levels (High/Medium/Low).
        """
        scores = {}
        
        # 1. Active/Direct modules (High Confidence)
        if module_name in ["ports", "ssl", "headers", "code_leaks", "network_footprint"]:
            # These are direct observations or verifiable crypto/API data.
            # We can assign High to all fields or specific ones.
            # For simplicity, we assume the entire module's findings are High confidence unless header-based.
            return {"_global": "High"} 

        # 2. DNS (High for existence, Medium for specific analysis)
        elif module_name == "dns":
            for key in data.keys():
                if key in ["email_security", "flags"]: continue
                scores[key] = "High" # Resolution confirmed
            if "email_security" in data:
                 scores["email_security"] = "Medium" # Logic-based

        # 3. Whois (Medium - often stale or redacted)
        elif module_name == "whois":
            scores["_global"] = "Medium"

        # 4. Tech / Fingerprinting (Low/Medium - often spoofed or heuristic)
        elif module_name == "tech":
            scores["server"] = "Medium" # Specific header, spoofable
            scores["frameworks"] = "Low" # Often heuristic (cookies, generic headers)
            scores["proxies"] = "Medium"
            scores["os_hint"] = "Low"

        # 5. Subdomains (Medium - Passive sources can be stale)
        elif module_name == "subdomains":
            scores["subdomains"] = "Medium"

        # Fallback
        if not scores:
            scores["_global"] = "Low"
            
        return scores

    @staticmethod
    def enrich_findings(findings: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        return [ConfidenceEngine.enrich_finding(f) for f in findings]
