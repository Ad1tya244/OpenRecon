from fpdf import FPDF
from datetime import datetime
from typing import Dict, Any, List
import re

TITLE = "OpenRecon Security Assessment Report"
VERSION = "1.0.0"
DISCLAIMER = """
DISCLAIMER: This report is generated by an automated Open Source Intelligence (OSINT) tool.
The information contained herein is gathered from public sources and is intended for educational
and security assessment purposes only. The user is responsible for ensuring that this tool is 
used in compliance with all applicable laws and regulations.
"""

class PDF(FPDF):
    def header(self):
        self.set_font('helvetica', 'B', 15)
        self.cell(0, 10, TITLE, border=False, new_x="LMARGIN", new_y="NEXT", align='C')
        self.set_font('helvetica', 'I', 10)
        self.cell(0, 5, f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", new_x="LMARGIN", new_y="NEXT", align='C')
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('helvetica', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()}/{{nb}} - OpenRecon v{VERSION}', align='C')

    def chapter_title(self, label):
        self.set_font('helvetica', 'B', 12)
        self.set_fill_color(200, 220, 255)
        label = sanitize_text(label)
        self.cell(0, 8, label, new_x="LMARGIN", new_y="NEXT", fill=True)
        self.ln(4)

    def chapter_body(self, body):
        self.set_font('helvetica', '', 10)
        body = sanitize_text(body)
        self.multi_cell(0, 5, body)
        self.ln()
        
    def add_key_value(self, key, value):
        self.set_font('helvetica', 'B', 10)
        key = sanitize_text(str(key))
        label_w = 50
        
        if self.get_x() + label_w > self.w - self.r_margin:
            self.ln()
            
        self.cell(label_w, 6, key + ":", align='L', new_x="RIGHT", new_y="TOP")
        
        self.set_font('helvetica', '', 10)
        val_str = str(value)
        val_str = mask_sensitive_data(val_str)
        val_str = sanitize_text(val_str)
        
        # w=0 -> extend to right margin
        self.multi_cell(0, 6, val_str, new_x="LMARGIN", new_y="NEXT")
        
    def add_list_item(self, item):
        self.set_font('helvetica', '', 10)
        marker_w = 10
        
        if self.get_x() + marker_w > self.w - self.r_margin:
            self.ln()
            
        self.cell(marker_w, 6, "-", new_x="RIGHT", new_y="TOP")
        
        item_str = mask_sensitive_data(str(item))
        item_str = sanitize_text(item_str)
        
        self.multi_cell(0, 6, item_str, new_x="LMARGIN", new_y="NEXT")

def mask_sensitive_data(text: str) -> str:
    patterns = [
        (r'(api_key|apikey|secret|token|password|passwd|pwd)\s*[:=]\s*["\'](.*?)["\']', r'\1 = "***"'),
        (r'(api_key|apikey|secret|token|password|passwd|pwd)\s*[:=]\s*([a-zA-Z0-9_\-]{8,})', r'\1 = "***"')
    ]
    masked_text = text
    for pattern, replacement in patterns:
        try:
             masked_text = re.sub(pattern, replacement, masked_text, flags=re.IGNORECASE)
        except:
            pass
    return masked_text

def sanitize_text(text: str) -> str:
    return text.encode('latin-1', 'replace').decode('latin-1')

def format_date(date_str: Any) -> str:
    if not date_str or str(date_str).lower() in ["none", "unknown", "n/a"]:
        return "Unknown"
    
    s = str(date_str).split('.')[0]
    formats = ["%Y-%m-%dT%H:%M:%S", "%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
    
    for fmt in formats:
        try:
            dt = datetime.strptime(s, fmt)
            return dt.strftime("%d/%m/%Y")
        except ValueError:
            continue
    return str(date_str)

def generate_report(scan_data: Dict[str, Any], output_path: str = "report.pdf") -> str:
    """
    Generates PDF based on strictly ordered sections:
    1. Infrastructure & Hosting
    2. DNS Record
    3. Domain Registration
    4. Subdomains
    5. SSL/TLS Security
    6. Security Headers
    7. Email Security
    8. Technology Stack
    9. Open Ports
    10. Network Footprint
    11. Public Files
    12. Historical Intelligence
    13. Intelligence Analyzer Data
    """
    pdf = PDF()
    pdf.add_page()
    
    # Disclaimer
    pdf.set_font('helvetica', 'B', 10)
    pdf.set_text_color(200, 0, 0)
    pdf.multi_cell(0, 5, DISCLAIMER, align='C')
    pdf.set_text_color(0, 0, 0)
    pdf.ln(10)
    
    # Extract Modules (Safe gets)
    full = scan_data.get("full_results") or {}
    target = scan_data.get("target", "Unknown")
    
    # 1. Infrastructure & Hosting
    pdf.chapter_title("1. Infrastructure & Hosting")
    ip_intel = full.get("ip_intelligence") or {}
    
    # Dashboard checks ip_intelligence.ips[0]
    if isinstance(ip_intel, dict) and ip_intel.get("ips") and len(ip_intel["ips"]) > 0:
        primary = ip_intel["ips"][0]
        pdf.add_key_value("Primary IP", primary.get("ip", "Unknown"))
        pdf.add_key_value("Location", primary.get("location", "Unknown"))
        pdf.add_key_value("ISP / Org", primary.get("isp", "Unknown"))
        pdf.add_key_value("ASN", primary.get("asn", "Unknown"))
        pdf.add_key_value("Hosting Type", primary.get("hosting_type", "Unknown"))
        
        flags = ip_intel.get("flags", [])
        pdf.add_key_value("Risk Flags", ", ".join(flags) if flags else "None")
    else:
        # Fallback if structure differs or empty
        pdf.chapter_body("No detailed infrastructure data available.")
        
    pdf.ln(5)

    # 2. DNS Record
    pdf.chapter_title("2. DNS Record")
    dns = full.get("dns") or {}
    if dns:
        for type, records in dns.items():
            if type == "email_security": continue # Skip
            if type == "flags": continue # Skip
            if records:
                pdf.add_key_value(type, ", ".join(str(r) for r in records) if isinstance(records, list) else str(records))
    else:
        pdf.chapter_body("No DNS records found.")
    pdf.ln(5)

    # 3. Domain Registration (Whois)
    pdf.chapter_title("3. Domain Registration")
    whois = full.get("whois") or {}
    if isinstance(whois, dict) and "error" not in whois:
        pdf.add_key_value("Registrar", whois.get("registrar", "Unknown"))
        
        created = whois.get("creation_date_iso") or whois.get("creation_date")
        pdf.add_key_value("Created Date", format_date(created))
        
        age = whois.get("age_days")
        if age:
             pdf.add_key_value("Age", f"{age} days")
             
        pdf.add_key_value("Expiration Date", format_date(whois.get("expiration_date")))
        
        flags = whois.get("flags")
        if flags:
             pdf.add_key_value("Flags", ", ".join(flags))
             
        # Optional extra details
        if whois.get("registrant") and whois.get("registrant") != "Redacted":
            pdf.add_key_value("Registrant", str(whois.get("registrant")))
            
    else:
        pdf.chapter_body("Whois data unavailable.")
    pdf.ln(5)

    # 4. Subdomains
    pdf.chapter_title("4. Subdomains")
    sub_data = full.get("subdomains") or {}
    # Handle different structures
    if isinstance(sub_data, list):
         sub_list = sub_data
    elif isinstance(sub_data, dict):
         sub_list = sub_data.get("subdomains", [])
    else:
         sub_list = []
    
    if sub_list:
        pdf.add_key_value("Total Found", len(sub_list))
        for item in sub_list:
            if isinstance(item, str):
                text = item
            else:
                host = item.get("hostname", "")
                flags = item.get("flags", [])
                text = f"{host} [{', '.join(flags)}]" if flags else host
            pdf.add_list_item(text)
    else:
        pdf.chapter_body("No subdomains found.")
    pdf.ln(5)

    # 5. SSL/TLS Security
    pdf.chapter_title("5. SSL/TLS Security")
    ssl = full.get("ssl") or {}
    if ssl:
         status = "Valid" if ssl.get("valid") else ("Expired" if ssl.get("is_expired") else "Invalid")
         pdf.add_key_value("Status", status)
         
         issuer = ssl.get("issuer", {})
         issuer_name = issuer.get("organizationName") or issuer.get("commonName") or "Unknown"
         pdf.add_key_value("Issuer", str(issuer_name))
         
         pdf.add_key_value("Valid From", format_date(ssl.get("valid_from") or ssl.get("notBefore")))
         pdf.add_key_value("Valid Until", format_date(ssl.get("valid_until") or ssl.get("notAfter")))
         
         if ssl.get("serial_number"):
             pdf.add_key_value("Serial Number", str(ssl.get("serial_number")))
         if ssl.get("signature_algorithm"):
             pdf.add_key_value("Signature Algo", str(ssl.get("signature_algorithm")))
             
         if ssl.get("protocol"):
             pdf.add_key_value("Protocol", ssl.get("protocol"))
    else:
        pdf.chapter_body("SSL/TLS data unavailable.")
    pdf.ln(5)

    # 6. Security Headers
    pdf.chapter_title("6. Security Headers")
    sec = full.get("headers") or {}
    if not sec or sec.get("error"):
         pdf.chapter_body(f"Error: {sec.get('error', 'No data')}")
    else:
        pdf.add_key_value("Overall Score", sec.get("score", "N/A"))
        
        # Specific headers check (like dashboard)
        headers_map = sec.get("headers", {})
        
        checks = [
            ("Strict-Transport-Security", "strict-transport-security"),
            ("Content-Security-Policy", "content-security-policy"),
            ("X-Frame-Options", "x-frame-options"),
            ("X-Content-Type-Options", "x-content-type-options"),
            ("Referrer-Policy", "referrer-policy"),
            ("Permissions-Policy", "permissions-policy")
        ]
        
        for name, key in checks:
            present = headers_map.get(key)
            status = "Present" if present else "Missing"
            pdf.add_key_value(name, status)
            
    pdf.ln(5)

    # 7. Email Security
    pdf.chapter_title("7. Email Security")
    email_sec = (full.get("dns") or {}).get("email_security") or {}
    if email_sec:
        # SPF
        spf = email_sec.get("spf") or {}
        pdf.add_key_value("SPF Record", "Present" if spf.get("present") else "Missing")
        if spf.get("status"): pdf.add_key_value("SPF Status", spf.get("status"))
        
        # DMARC
        dmarc = email_sec.get("dmarc") or {}
        pdf.add_key_value("DMARC Record", "Present" if dmarc.get("present") else "Missing")
        if dmarc.get("policy"): pdf.add_key_value("Policy", dmarc.get("policy"))
        
        # DKIM
        dkim = email_sec.get("dkim_dns_check") or {}
        dkim_status = "Present" if dkim.get("_domainkey_exists") else "Not Found (Passive)"
        pdf.add_key_value("DKIM Hint", dkim_status)
    else:
        pdf.chapter_body("No explicit email security data found.")
    pdf.ln(5)

    # 8. Technology Stack
    pdf.chapter_title("8. Technology Stack")
    tech = full.get("tech") or {}
    if tech and not tech.get("error"):
        pdf.add_key_value("Server", tech.get("server", "Unknown"))
        if tech.get("frameworks"):
            pdf.add_key_value("Frameworks", ", ".join(tech.get("frameworks")))
        if tech.get("proxies"):
            pdf.add_key_value("Proxies", ", ".join(tech.get("proxies")))
        if tech.get("os_hint"):
             pdf.add_key_value("Aggregated OS", tech.get("os_hint"))
    else:
        pdf.chapter_body("No technology stack detected.")
    pdf.ln(5)

    # 9. Open Ports
    pdf.chapter_title("9. Open Ports")
    ports = full.get("ports") or {}
    open_ports = ports.get("open_ports") or []
    if open_ports:
        # Sort by port like dashboard
        try:
            open_ports.sort(key=lambda x: int(x.get("port", 0)))
        except:
            pass
            
        for p in open_ports:
            # Dashboard format: 80/http
            pdf.add_list_item(f"{p.get('port')}/{p.get('service')} - {p.get('banner', 'No banner')}")
    else:
        pdf.chapter_body("No open ports detected on target.")
    pdf.ln(5)

    # 10. Network Footprint (Detailed)
    pdf.chapter_title("10. Detailed Network Footprint")
    net = full.get("network_footprint") or {}
    if net and not net.get("error"):
         summary = net.get("summary") or {}
         exposure = net.get("exposure_analysis") or {}
         graph = net.get("network_graph") or {}
         
         pdf.add_key_value("Total Unique IPs", summary.get("unique_ips", 0))
         pdf.add_key_value("Unique ASNs", summary.get("unique_asns", 0))
         
         providers = summary.get("hosting_providers")
         if providers:
             pdf.add_key_value("Hosting Providers", ", ".join(providers))
             
         cdns = graph.get("cdns")
         if cdns:
             pdf.add_key_value("CDNs Detected", ", ".join(cdns))
             
         if exposure.get("cloud_ips"):
              pdf.add_key_value("Cloud IPs", exposure.get("cloud_ips"))
              
         unprotected = exposure.get("unprotected_ips", 0)
         if unprotected > 0:
             pdf.set_text_color(200, 0, 0)
             ip_list = exposure.get("unprotected_ips_list", [])
             val = f"{unprotected}"
             if ip_list: val += f" ({', '.join(ip_list)})"
             pdf.add_key_value("Unprotected IPs", val)
             pdf.set_text_color(0, 0, 0)
    else:
        pdf.chapter_body("No network footprint data available.")
    pdf.ln(5)

    # 11. Public Files & Leaks
    pdf.chapter_title("11. Public Files & Code Leaks")
    
    # Public Files
    files = full.get("public_files") or {}
    found_files = files.get("found", [])
    interesting = files.get("interesting_findings", [])
    
    # Dashboard uses 'files.found' list directly sometimes, sometimes it's object
    # In earlier mapping: "Found Files": data.public_files.found.join()
    # In earlier mapping: "Insights": data.public_files.interesting_findings.join()
    
    has_files = False
    
    if found_files:
        has_files = True
        pdf.cell(0, 6, "Found Files:", new_x="LMARGIN", new_y="NEXT")
        for f in found_files:
             pdf.add_list_item(str(f)) # It might be a list of strings now based on dashboard
             
    if interesting:
        has_files = True
        pdf.ln(2)
        pdf.cell(0, 6, "Insights:", new_x="LMARGIN", new_y="NEXT")
        for i in interesting:
            pdf.add_list_item(str(i))
    
    # Code Leaks
    leaks = full.get("code_leaks") or {}
    leak_findings = leaks.get("findings", [])   
    if leak_findings:
        has_files = True
        pdf.ln(2)
        pdf.cell(0, 6, "Code Leaks:", new_x="LMARGIN", new_y="NEXT")
        for leak in leak_findings:
            repo = leak.get("repository", "Unknown")
            url = leak.get("url", "")
            pdf.add_list_item(f"{repo} ({url})")
    elif leaks.get("message"):
         # "No leaks found" message
         pass
            
    # Directory Exposure
    dirs = full.get("directory_exposure") or {}
    exposed_dirs = dirs.get("exposed_directories", [])
    if exposed_dirs:
        has_files = True
        pdf.ln(2)
        pdf.cell(0, 6, "Directory Listings:", new_x="LMARGIN", new_y="NEXT")
        for d in exposed_dirs:
            if isinstance(d, dict):
                 pdf.add_list_item(f"{d.get('url')} (Status: {d.get('status')})")
            else:
                 pdf.add_list_item(str(d))
            
    if not has_files:
        pdf.chapter_body("No public files, leaks, or exposed directories found.")
    pdf.ln(5)

    # 12. Historical Intelligence
    pdf.chapter_title("12. Historical Intelligence")
    hist = full.get("historical") or {}
    if hist:
        has_hist_data = False
        stack = hist.get("tech_stack_history") or []
        if stack:
            pdf.add_key_value("Past Tech Stack", ", ".join(mask_sensitive_data(str(x)) for x in stack))
            has_hist_data = True
        
        old_files = hist.get("interesting_files") or []
        if old_files:
             # Limit to 5 like dashboard
             pdf.add_key_value("Interesting Old Files", ", ".join(old_files[:5]))
             has_hist_data = True
        
        endpoints = hist.get("historical_endpoints") or []
        if endpoints:
            pdf.add_key_value("Wayback Endpoints", f"{len(endpoints)} unique paths found")
            has_hist_data = True
            
        if not has_hist_data:
             pdf.chapter_body("No historical data available (Archive returned no significant results).")
    else:
        pdf.chapter_body("No historical data available.")
    pdf.ln(5)

    # 13. Intelligence Analyzer Data (General)
    pdf.chapter_title("13. Strategic Intelligence (General)")
    findings = scan_data.get("intelligence") or []
    
    # Filter general findings vs attack paths
    general_findings = [f for f in findings if "Attack Vector:" not in f.get("title", "")]
    attack_paths = [f for f in findings if "Attack Vector:" in f.get("title", "")]
    
    if general_findings:
        for finding in general_findings:
            title = finding.get("title", "Unknown")
            severity = finding.get("severity", "Unknown")
            
            pdf.set_font('helvetica', 'B', 11)
            # existing color logic
            if severity == "High": pdf.set_text_color(220, 38, 38)
            elif severity == "Medium": pdf.set_text_color(234, 88, 12)
            else: pdf.set_text_color(0, 100, 200)
            
            pdf.cell(0, 7, f"{title} [{severity}]", new_x="LMARGIN", new_y="NEXT")
            pdf.set_text_color(0, 0, 0)
            
            desc = finding.get("description", "")
            pdf.set_font('helvetica', '', 10)
            pdf.multi_cell(0, 5, desc)
            
            signals = finding.get("signals") or []
            if signals:
                 pdf.ln(2)
                 for s in signals:
                     pdf.add_list_item(str(s))
            pdf.ln(3)
    else:
        pdf.chapter_body("No strategic intelligence findings detected.")
    pdf.ln(5)

    # 14. Attack Path Analysis
    pdf.chapter_title("14. Attack Path Prioritization")
    if attack_paths:
        pdf.chapter_body("Simulated attack vectors based on OSINT inferred converging risks.")
        pdf.ln(2)
        
        for path in attack_paths:
             # Remove prefix "Attack Vector: " for cleaner PDF title
             raw_title = path.get("title", "").replace("Attack Vector: ", "")
             severity = path.get("severity", "Medium")
             
             pdf.set_font('helvetica', 'B', 11)
             if severity == "High": pdf.set_text_color(220, 38, 38) # Red
             else: pdf.set_text_color(234, 88, 12) # Orange
             
             pdf.cell(0, 7, f"Path: {raw_title} [{severity}]", new_x="LMARGIN", new_y="NEXT")
             pdf.set_text_color(0, 0, 0)
             
             desc = path.get("description", "")
             pdf.set_font('helvetica', '', 10)
             pdf.multi_cell(0, 5, desc)
             
             pdf.ln(2)
             signals = path.get("signals") or []
             if signals:
                 pdf.set_font('helvetica', 'I', 9)
                 pdf.cell(0, 5, "Execution Sequence & Evidence:", new_x="LMARGIN", new_y="NEXT")
                 for s in signals:
                     pdf.add_list_item(str(s))
             pdf.ln(4)
    else:
        pdf.chapter_body("No high-confidence attack paths identified.")

    # Save
    try:
        pdf.output(output_path)
        return output_path
    except Exception as e:
        return f"Error generating PDF: {str(e)}"
