from fpdf import FPDF
from datetime import datetime
from typing import Dict, Any
import re

TITLE = "OpenRecon Security Assessment Report"
VERSION = "1.0.0"
DISCLAIMER = """
DISCLAIMER: This report is generated by an automated Open Source Intelligence (OSINT) tool.
The information contained herein is gathered from public sources and is intended for educational
and security assessment purposes only. The user is responsible for ensuring that this tool is 
used in compliance with all applicable laws and regulations.
"""

class PDF(FPDF):
    def header(self):
        self.set_font('helvetica', 'B', 15)
        self.cell(0, 10, TITLE, border=False, new_x="LMARGIN", new_y="NEXT", align='C')
        self.set_font('helvetica', 'I', 10)
        self.cell(0, 5, f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", new_x="LMARGIN", new_y="NEXT", align='C')
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('helvetica', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()}/{{nb}} - OpenRecon v{VERSION}', align='C')

    def chapter_title(self, label):
        self.set_font('helvetica', 'B', 12)
        self.set_fill_color(200, 220, 255)
        label = sanitize_text(label)
        self.cell(0, 8, label, new_x="LMARGIN", new_y="NEXT", fill=True)
        self.ln(4)

    def chapter_body(self, body):
        self.set_font('helvetica', '', 10)
        body = sanitize_text(body)
        self.multi_cell(0, 5, body)
        self.ln()
        
    def add_key_value(self, key, value):
        self.set_font('helvetica', 'B', 10)
        # Sanitize Key
        key = sanitize_text(str(key))
        # Ensure we start at left margin? No, we trust caller, but let's be safe?
        # self.set_x(self.l_margin) 
        # Using new_x="RIGHT" for the label cell to move cursor for the value
        self.cell(50, 6, key + ":", align='L', new_x="RIGHT", new_y="TOP")
        
        self.set_font('helvetica', '', 10)
        # Clean value
        val_str = str(value)
        # Escape/Mask logic
        val_str = mask_sensitive_data(val_str)
        # Sanitize Value
        val_str = sanitize_text(val_str)
        
        # multi_cell with new_x="LMARGIN", new_y="NEXT" to reset line for next item
        self.multi_cell(0, 6, val_str, new_x="LMARGIN", new_y="NEXT")
        
    def add_list_item(self, item):
        self.set_font('helvetica', '', 10)
        self.cell(10, 6, "-", new_x="RIGHT", new_y="TOP")
        # Sanitize
        item_str = mask_sensitive_data(str(item))
        item_str = sanitize_text(item_str)
        self.multi_cell(0, 6, item_str, new_x="LMARGIN", new_y="NEXT")

def mask_sensitive_data(text: str) -> str:
    """ Masks potential API keys or secrets in output. """
    # Same patterns as code_leak_recon
    patterns = [
        (r'(api_key|apikey|secret|token|password|passwd|pwd)\s*[:=]\s*["\'](.*?)["\']', r'\1 = "***"'),
        (r'(api_key|apikey|secret|token|password|passwd|pwd)\s*[:=]\s*([a-zA-Z0-9_\-]{8,})', r'\1 = "***"')
    ]
    masked_text = text
    for pattern, replacement in patterns:
        try:
             masked_text = re.sub(pattern, replacement, masked_text, flags=re.IGNORECASE)
        except:
            pass
    return masked_text

def sanitize_text(text: str) -> str:
    """
    Sanitize text for PDF compatible latin-1 encoding usually, 
    but fpdf2 handles unicode better if font is loaded.
    By default core fonts are latin-1.
    We'll do basic replacement of unprintable chars.
    """
    return text.encode('latin-1', 'replace').decode('latin-1')

def generate_report(scan_data: Dict[str, Any], output_path: str = "report.pdf") -> str:
    """
    Generates a PDF report from the full scan data.
    """
    pdf = PDF()
    pdf.add_page()
    
    # Disclaimer
    pdf.set_font('helvetica', 'B', 10)
    pdf.set_text_color(200, 0, 0)
    pdf.multi_cell(0, 5, DISCLAIMER, align='C')
    pdf.set_text_color(0, 0, 0)
    pdf.ln(10)
    
    # Target Info
    target = scan_data.get("target", "Unknown")
    pdf.chapter_title(f"Target: {target}")
    
    # Risk Assessment
    attack_surface = scan_data.get("attack_surface", {})
    risk = attack_surface.get("risk_assessment", {})
    
    pdf.set_font('helvetica', 'B', 12)
    pdf.cell(40, 10, f"Risk Grade: {risk.get('grade', 'N/A')}")
    pdf.cell(40, 10, f"Score: {risk.get('score', 0)}")
    pdf.ln(15)
    
    # Executive Summary
    pdf.chapter_title("Executive Summary")
    summary = attack_surface.get("summary", {})
    pdf.add_key_value("Critical Risks", summary.get("critical_risks", 0))
    pdf.add_key_value("Medium Risks", summary.get("medium_risks", 0))
    pdf.add_key_value("Total Subdomains", summary.get("total_subdomains", 0))
    pdf.ln(5)
    
    # Detailed Findings - by Module
    full_results = scan_data.get("full_results", {})
    
    # 1. Tech Stack
    pdf.chapter_title("Technology Stack")
    tech = full_results.get("tech", {})
    pdf.add_key_value("Server", tech.get("server", "Unknown"))
    if tech.get("frameworks"):
        pdf.add_key_value("Frameworks", ", ".join(tech.get("frameworks")))
    if tech.get("proxies"):
        pdf.add_key_value("Proxies", ", ".join(tech.get("proxies")))
    pdf.ln(5)

    # 2. Key Risks / Exposure Points
    pdf.chapter_title("High Priority Exposures")
    exposures = attack_surface.get("exposure_points", [])
    if exposures:
        for item in exposures:
            pdf.add_list_item(f"{item.get('type')}: {item.get('details') or item.get('paths')}")
    else:
        pdf.chapter_body("No critical exposure points identified.")
    
    # 3. Security Headers
    pdf.chapter_title("Security Headers Policy")
    sec_headers = full_results.get("security_headers", {})
    missing = sec_headers.get("missing_headers", [])
    if missing:
        pdf.set_text_color(200, 0, 0)
        pdf.chapter_body(f"Missing {len(missing)} recommended headers:")
        pdf.set_text_color(0, 0, 0)
        for m in missing:
            pdf.add_list_item(f"{m.get('header')}: {m.get('description')}")
    else:
        pdf.chapter_body("Good security header posture detected.")

    # 4. Recon Data Summaries
    pdf.chapter_title("Network Reconnaissance Data")
    
    # DNS
    dns = full_results.get("dns", {})
    if dns:
        pdf.add_key_value("DNS Records", f"Found records for {', '.join(dns.keys())}")
        
    # SSL
    ssl_res = full_results.get("ssl", {})
    if ssl_res:
         status = "Expired" if ssl_res.get("is_expired") else "Valid"
         pdf.add_key_value("SSL Status", status)
         pdf.add_key_value("Issuer", str(ssl_res.get("issuer", {}).get("commonName", "Unknown")))

    # Subdomains (Limit output)
    sub_data = full_results.get("subdomains", {})
    if isinstance(sub_data, list):
         sub_list = sub_data
    else:
         sub_list = sub_data.get("subdomains", [])

    if sub_list:
        count = len(sub_list)
        pdf.chapter_title(f"Subdomains ({count} found)")
        # Print first 20
        idx = 0
        for item in sub_list:
            if idx >= 20: 
                break
            
            if isinstance(item, str):
                text = item
            else:
                # Dict with flags
                host = item.get("hostname", "")
                flags = item.get("flags", [])
                if flags:
                    text = f"{host} [{', '.join(flags)}]"
                else:
                    text = host
                    
            pdf.add_list_item(text)
            idx += 1
            
        if count > 20:
            pdf.add_list_item(f"... and {count-20} more.")

    # Save
    try:
        pdf.output(output_path)
        return output_path
    except Exception as e:
        return f"Error generating PDF: {str(e)}"
